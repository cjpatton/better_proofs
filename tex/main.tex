\documentclass{article}
\usepackage{amsmath, amsthm}
\usepackage{listings}
\usepackage{listings-rust}
\usepackage[margin=1in]{geometry}
\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage[svgnames]{xcolor}

\lstset{
  language=rust,
  style=boxed,
}

% Colors

\definecolor{darkgreen}{RGB}{30,97,0}

% Theorems

\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}

% Macros

\newcommand{\authnote}[3]{%
  {
    \color{#1}%
    \textbf{[#2:~}%
    {%
      #3%
    }%
    \textbf{]}%
  }%
}
\newcommand{\cp}[1]{\authnote{darkgreen}{Chris P.}{#1}}

\newcommand{\Adv}[1]{\textrm{\textup{Adv}}^{\textup{#1}}}
\newcommand{\Prob}[1]{\Pr\hspace{-1pt}\big[\,#1\,\big]}
\newcommand{\code}[1]{\textrm{\textup{\lstinline{#1}}}}

\title{Better proofs}
\author{Christopher Patton ({\texttt{\small chrispatton+ietf@gmail.com}})}

\begin{document}

\maketitle

\begin{abstract}
  \cp{TODO.}
\end{abstract}

\section{Introduction}

\cp{TODO.}

\section{Notation}

All algorithms, including adversaries, are rust programs without async
semantics (i.e., with the $\code{async}$ and $\code{await}$ key words removed).
%
By convention, an adversary's runtime includes the time it takes to initialize
its game and evaluate its oracle queries.
%
Let $\code{block}$ be a rust code block whose last statement is an expression
that evaluates to $\code{bool}$.
%
We denote by $\Prob{\code{block}}$ the probability that execution of
$\code{block}$ halts (without panicking) and outputs $\code{true}$.

\section{Example: Hybrid Encryption}

In this section we consider the hybrid public-key encryption (PKE) scheme of
\cite[Chapter~15]{joy}.
%
The proof demonstrates two types of game transitions: \emph{equivalent-rewrite}
and \emph{equivalent-by-reduction}.

\subsection{Syntax}

A PKE scheme implements the $\code{PubEnc}$ trait listed in
Figure~\ref{fig/pubenc/syntax}.
%
Let $\code{enc: E}$ implement $\code{PubEnc}$.
%
We say $\code{enc}$ is \emph{correct} if for all $\code{m} \in
\code{E::Plaintext}$ it holds that
%
\[
  \Prob{
    \code{let (pk, sk) = enc.key_gen();
    enc.decrypt(sk, enc.encrypt(pk, m)) == Some(m)}
  } = 1 \,.
\]

\subsection{Security}

Security under chosen plaintext attack (CPA) is defined by the $\code{PubCpa}$
game in Figure~\ref{fig/pubenc/security}.
%
It captures a left-or-right notion of indistinguishability by giving the
attacker an oracle \hyperref[sec/traits]{$\code{LeftOrRight}$} that encrypts
one of two messages chosen by the attacker and returns the ciphertext.
%
Which message is encrypted is controlled by a boolean $\code{right}$ used to
initialize the game.

\begin{definition}[{\cite[Definition 15.1]{joy}}]
  Let~$A$ implement \hyperref[sec/traits]{$\code{Distinguisher}$}.
  %
  Let~$\code{enc}$ implement \hyperref[fig/pubenc/syntax]{$\code{PubEnc}$}.
  %
  Define the advantage of attacker~$A$ in breaking the security of
  $\code{enc}$ under CPA as
  %
  \[
    \Adv{cpa}_{\code{enc}}(A) =
      \Prob{A\code{.play(PubCpa::init(enc, false))}} -
      \Prob{A\code{.play(PubCpa::init(enc, true))}} \,,
  \]
  %
  where $\code{PubCpa}$ is as defined in Figure~\ref{fig/pubenc/security}.
  %
  Informally, we say $\code{enc}$ is secure under CPA if every efficient
  attacker has small advantage.
\end{definition}

\begin{remark}
  This definition implicitly requires length hiding, since there is no
  requirement that the challenge plaintext $\code{m_left}$ and $\code{m_right}$
  have the same length. For most PKE schemes, the length of the ciphertext is a
  function of the length of the plaintext.
\end{remark}

% ../src/joy/hybrid/mod.rs
\begin{figure}
\begin{lstlisting}
/// Syntax.
pub trait PubEnc {
    type PublicKey;
    type SecretKey;
    type Plaintext;
    type Ciphertext;
    fn key_gen(&self) -> (Self::PublicKey, Self::SecretKey);
    fn encrypt(&self, pk: &Self::PublicKey, m: &Self::Plaintext) -> Self::Ciphertext;
    fn decrypt(
        &self,
        sk: &Self::SecretKey,
        c: &Self::Ciphertext,
    ) -> Option<Self::Plaintext>;

/// Security.
pub struct PubCpa<E: PubEnc> {
    enc: E,
    pk: E::PublicKey,
    right: bool,
}
impl<E: PubEnc> PubCpa<E> {
    pub fn init(enc: E, right: bool) -> Self {
        let (pk, _sk) = e.key_gen();
        Self { enc, pk, right }
    }
}
impl<E: PubEnc> GetPublicKey for PubCpa<E> {
    type PublicKey = E::PublicKey;
    fn get_pk(&self) -> &E::PublicKey {
        &self.pk
    }
}
impl<E: SymEnc> LeftOrRight for Cpa<E> {
    type Plaintext = E::Plaintext;
    type Ciphertext = E::Ciphertext;
    fn left_or_right(&self, m_left: &E::Plaintext, m_right: &E::Plaintext) -> E::Ciphertext {
        if self.right {
            self.enc.encrypt(&self.k, m_right)
        } else {
            self.enc.encrypt(&self.k, m_left)
        }
    }
}
\end{lstlisting}
  \caption{Syntax of public-key encryption (PKE) and game game
  \lstinline{PubCpa} for defining security of PKE under chosen plaintext attack
  (CPA).}
  \label{fig/pubenc/security}
  \label{fig/pubenc/syntax}
\end{figure}

\subsection{Construction}

In practice, PKE schemes are constructed by combining symmetric encryption with
a mechanism for encapsulating the encryption key to the intended
recipient~\cite{rfc9180} (that is, the holder of the secret key corresponding
to the public encapsulation key).
%
By way of gentle introduction to this paradigm, Mike Rosulek gives a
construction of CPA-secure, hybrid encryption in ``The Joy of
Cryptography''~\cite{joy}.
%
We recall this construction in Figure~\ref{fig/hybrid}.

\begin{figure}[t]
\begin{lstlisting}
pub struct Hybrid<P, S> {
    pub pub_enc: P,
    pub sym_enc: S,
}
impl<P, S> PubEnc for Hybrid<P, S>
where
    S: SymEnc,
    P: PubEnc<Plaintext = S::Key>,
    Standard: Distribution<S::Key>,
{
    type PublicKey = P::PublicKey;
    type SecretKey = P::SecretKey;
    type Plaintext = S::Plaintext;
    type Ciphertext = (P::Ciphertext, S::Ciphertext);
    fn key_gen(&self) -> (P::PublicKey, P::SecretKey) {
        self.pub_enc.key_gen()
    }
    fn encrypt(&self, pk: &P::PublicKey, m: &S::Plaintext) -> (P::Ciphertext, S::Ciphertext) {
        let tk = thread_rng().gen(); // "temporary key"
        let c_pub = self.pub_enc.encrypt(pk, &tk);
        let c_sym = self.sym_enc.encrypt(&tk, m);
        (c_pub, c_sym)
    }
    fn decrypt(
        &self,
        sk: &Self::SecretKey,
        (c_pub, c_sym): &(P::Ciphertext, S::Ciphertext),
    ) -> Option<Self::Plaintext> {
        let tk = self.pub_enc.decrypt(sk, c_pub)?;
        let m = self.sym_enc.decrypt(&tk, c_sym)?;
        Some(m)
    }
}
\end{lstlisting}
  \caption{Hybrid PKE scheme of \cite[Construction 15.8]{joy}.}
  \label{fig/hybrid}
\end{figure}

This construction transforms a symmetric encryption scheme $\code{sym_enc: S}$
into a PKE scheme.
%
The syntax and security of symmetric encryption are defined similarly to PKE,
except there is no public key; we defer the formal definition to
Appendix~\ref{sec/symenc}.
%
The transformation involves a PKE scheme $\code{pub_enc: E}$ with a small
plaintext space. In particular, we require that plaintext space of
$\code{pub_enc}$ is the same as the key space for $\code{sym_enc}$. Formally,
$\code{E: PubEnc<Plaintext = S::Key>}$ (see line 8).

To encrypt a plaintext, we choose a ``temporary key'' $\code{tk}$ uniform
randomly from the key space of $\code{sym_enc}$.
%
We then encrypt $\code{tk}$ using the PKE scheme $\code{pub_enc}$.
%
Finally, we encrypt the plaintext under $\code{tk}$ and output both
ciphertexts.

\begin{theorem}\label{thm/hybrid}
  Suppose that $\code{pub_enc}$ and $\code{sym_enc}$ satisfy the constraints of
  Figure~\ref{fig/hybrid} and let $\code{hybrid} = \code{Hybrid\{
    pub_enc, sym_enc \}}$.
  %
  Then for every $\code{hybrid}$-attacker $A$ there exist a
  $\code{sym_enc}$-attacker $B$ and a $\code{pub_enc}$-attacker $C$ with
  the same runtime as $A$ for which
  %
  \[
    \Adv{cpa}_\code{hybrid}(A) \leq
      \Adv{cpa}_\code{sym_enc}(B) +
      2\cdot\Adv{cpa}_\code{pub_enc}(C) \,.
  \]
\end{theorem}

\begin{proof}
  \input{hybrid-proof}
\end{proof}

\section{Example: The PRP/PRF Switching Lemma}

In this section we fix the PRP/PRF switching lemma~\cite{br06}, which states
that a good pseudorandom permutation (PRP) is a good pseudorandom function
(PRF) up to birthday attacks.
%
The proof demonstrates the \emph{equivalent-until-bad} transition.

Syntactically, both a PRP and PRF implement the $\code{Eval}$ trait listed in
Figure~\ref{fig/func/syntax}.\footnote{A PRP also implements the inverse of
$\code{Eval::eval()}$. We do not list this syntax because it is not needed
here.}
%


\begin{figure}
\begin{lstlisting}
/// Syntax.
pub trait Func {
    type Key;
    type Domain: ?Sized;
    type Range;
    fn eval(&self, k: &Self::Key, x: &Self::Domain) -> Self::Range;
}

/// Real game for defining PRP/PRF security.
pub struct Real<F: Func> {
    f: F,
    k: F::Key,
}
impl<F: Func> Real<F>
where
    Standard: Distribution<F::Key>,
{
    pub fn with(f: F) -> Self {
        let k = thread_rng().gen();
        Self { f, k }
    }
}
impl<F: Func> Eval<F> for Real<F> {
    fn eval(&mut self, x: &F::Domain) -> F::Range {
        self.f.eval(&self.k, x)
    }
}
\end{lstlisting}
  \caption{Syntax and real security game for PRPs and PRFs. The ideal games are
  listed in Appendix~\ref{sec/func/ideal}.}
  \label{fig/func/syntax}
  \label{fig/func/real}
\end{figure}





\bibliographystyle{plain} % We choose the "plain" reference style
\bibliography{references}

\appendix

\section{Deferred Definitions}

\subsection{Symmetric Encryption}
\label{sec/symenc}

A symmetric encryption scheme implements the $\code{SymEnc}$ trait listed in
Figure~\ref{fig/symenc/syntax}.
%
Let $\code{enc: E}$ implement $\code{SymEnc}$.
%
We say $\code{enc}$ is \emph{correct} if for all $\code{m} \in
\code{E::Plaintext}$ it holds that
%
\[
  \Prob{
    \code{let k = e.key_gen();
    enc.decrypt(k, enc.encrypt(k, m)) == Some(m)}
  } = 1 \,.
\]
%
Security under chosen plaintext attack (CPA) is defined by the $\code{Cpa}$
game in Figure~\ref{fig/symenc/security}.

\begin{definition}[{\cite[Definition 7.1]{joy}}]
  Let $A$ implement \hyperref[sec/traits]{$\code{Distinguisher}$}.
  %
  Let~$\code{enc}$ implement \hyperref[fig/symenc/syntax]{$\code{SymEnc}$}.
  %
  Define the advantage of~$A$ in breaking the security of $\code{enc}$ under CPA
  as
  %
  \[
    \Adv{cpa}_{\code{enc}}(A) =
      \Prob{A\code{.play(Cpa::init(enc, false))}} -
      \Prob{A\code{.play(Cpa::init(enc, true))}} \,.
  \]
  %
  Informally, we say $\code{enc}$ is secure under CPA if every efficient adversary
  has small advantage.
\end{definition}

% ../src/joy/hybrid/mod.rs
\begin{figure}
\begin{lstlisting}
// Syntax
pub trait SymEnc {
    type Key;
    type Plaintext;
    type Ciphertext;
    fn key_gen(&self) -> Self::Key;
    fn encrypt(&self, k: &Self::Key, m: &Self::Plaintext) -> Self::Ciphertext;
    fn decrypt(&self, k: &Self::Key, c: &Self::Ciphertext) -> Option<Self::Plaintext>;
}

// Security
pub struct Cpa<E: SymEnc> {
    e: E,
    k: E::Key,
    right: bool,
}
impl<E: SymEnc> Cpa<E> {
    pub fn init(e: E, right: bool) -> Self {
        let k = e.key_gen();
        Self { e, k, right }
    }
}
impl<E: SymEnc> LeftOrRight for Cpa<E> {
    type Plaintext = E::Plaintext;
    type Ciphertext = E::Ciphertext;
    fn left_or_right(&self, m_left: &E::Plaintext, m_right: &E::Plaintext) -> E::Ciphertext {
        if self.right {
            self.enc.encrypt(&self.k, m_right)
        } else {
            self.enc.encrypt(&self.k, m_left)
        }
    }
}
\end{lstlisting}
  \caption{Syntax of symmetric encryption and game $\code{Cpa}$ for defining
  security of symmetric encryption under chosen plaintext attack (CPA) of
  symmetric encryption.}
  \label{fig/symenc/syntax}
  \label{fig/symenc/security}
\end{figure}

\subsection{Ideal games for defining PRPs and PRFs}
\label{sec/func/ideal}

\begin{lstlisting}
/// Ideal game for defining PRP security.
#[derive(Default)]
pub struct RandPerm<F: Func>
where
    F::Domain: Sized,
{
    table: HashMap<F::Domain, F::Range>,
    range: HashSet<F::Range>,
}
impl<F: Func> Eval<F> for RandPerm<F>
where
    Standard: Distribution<F::Range>,
    F::Domain: Clone + std::hash::Hash + Eq,
    F::Range: Clone + std::hash::Hash + Eq,
{
    fn eval(&mut self, x: &F::Domain) -> F::Range {
        let mut rng = thread_rng();
        self.table
            .entry(x.clone())
            .or_insert(loop {
                let y = rng.gen();
                if !self.range.contains(&y) {
                    self.range.insert(y.clone());
                    break y;
                }
            })
            .clone()
    }
}

/// Ideal game for defining PRF security.
#[derive(Default)]
pub struct RandFunc<F: Func>
where
    F::Domain: Sized,
{
    table: HashMap<F::Domain, F::Range>,
}
impl<F: Func> Eval<F> for RandFunc<F>
where
    Standard: Distribution<F::Range>,
    F::Domain: Clone + std::hash::Hash + Eq,
    F::Range: Clone + std::hash::Hash + Eq,
{
    fn eval(&mut self, x: &F::Domain) -> F::Range {
        self.table
            .entry(x.clone())
            .or_insert(thread_rng().gen())
            .clone()
    }
}
\end{lstlisting}

\subsection{Traits}
\label{sec/traits}

\begin{lstlisting}
/// A generic distinguishing attacker.
pub trait Distinguisher<G> {
    fn play(&self, game: G) -> bool;
}

/// Left-or-right encryption oracle.
pub trait LeftOrRight {
    type Plaintext;
    type Ciphertext;
    fn left_or_right(
        &self,
        m_left: &Self::Plaintext,
        m_right: &Self::Plaintext,
    ) -> Self::Ciphertext;
}

/// Oracle for obtaining the public key in a public-key cryptosystem.
pub trait GetPublicKey {
    type PublicKey;
    fn get_pk(&self) -> &Self::PublicKey;
}

/// Oracle for evaluating a keyed function.
pub trait Eval<F: Func> {
    fn eval(&mut self, x: &F::Domain) -> F::Range;
}
\end{lstlisting}

\end{document}
